"" General
set number	"" Show line numbers
set linebreak	"" Break lines at word (requires Wrap lines)
set showbreak=+++	"" Wrap-broken line prefix
set textwidth=0 "" Line wrap (number of cols)
set showmatch	"" Highlight matching brace
set visualbell	"" Use visual bell (no beeping)

set nowrap

set hlsearch	"" Highlight all search results
set smartcase	"" Enable smart-case search
set ignorecase	"" Always case-insensitive
set incsearch	"" Searches for strings incrementally

set autoindent	"" Auto-indent new lines
set shiftwidth=2	"" Number of auto-indent spaces
set smartindent	"" Enable smart-indent
set smarttab	"" Enable smart-tabs
set softtabstop=2	"" Number of spaces per Tab

"" Advanced
set nohlsearch
set ruler	"" Show row and column ruler information

set undolevels=1000	"" Number of undo levels
set backspace=indent,eol,start	"" Backspace behaviour



"" Generated by VimConfig.com
""set runtimepath="$VIMRUNTIME"

"" makes sure to load all the files in "autoload" before loading the rest of the vimrc
"" courtesy of DrAl
"" https://stackoverflow.com/a/4500936

"" this line loads plug.vim before the other files in the autoload directory,
"" because some of the other files depend on plug.vim being loaded

exe join(["source ",expand($VIMTIDALROOT),"/config/plug.vim"],"")

call plug#begin(expand($PACKAGEDIR))
    Plug 'tidalcycles/vim-tidal'
    Plug 'jiangmiao/auto-pairs'
    Plug 'tpope/vim-commentary'
    Plug 'tpope/vim-surround'
    Plug 'preservim/nerdtree'
call plug#end()

autocmd FileType tidal setlocal commentstring=--\ %s
autocmd BufRead,BufNewFile *.tidal setfiletype tidal
map <C-_> <Plug>Commentary

tnoremap <Esc> <C-\><C-n>

nmap Y "+y
nmap P "+p

let tidalRoot = expand($VIMTIDALROOT)

exec "set dictionary+=" . tidalRoot."/dict/samples_dict"
set complete=k,.,w,b,u,t

augroup FastEscape
    autocmd!
    au InsertEnter * set timeoutlen=0
    au InsertLeave * set timeoutlen=1000
augroup END

filetype plugin on
syntax on

""" When the filetype is FILETYPE then make AutoPairs only match for parenthesis
au Filetype tidal let b:AutoPairs = {"(": ")",'"':'"',"[":"]","{":"}","<":">"}

set nocp

"""set noswapfile "feel free to change


"" The Default NERDTree Bookmarks file
let g:NERDTreeBookmarksFile= expand($BOOKMARKSFILE)

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"" Misc Bindings 
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

"""Autopairs
let g:AutoPairsFlyMode = 0

"""NERDTree

nmap <C-D> :NERDTreeToggle <CR>
xmap <C-D> :NERDTreeToggle <CR>

let NERDTreeShowBookmarks=1

" many many thanks to Ingo Karkat
" https://stackoverflow.com/a/16378375
"
"
"
"
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"" Tidal mappings
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

function BindTidalEffect(effect, binding, prefix, ...)
  let l:value= a:0>=1 ? a:1 : "(8/8)"
  let l:postCommand = a:0>=2 ? a:2 : "r"
  let l:effectString= a:prefix." ".a:effect." ".value." <esc>F(l".postCommand
  let l:effectStringParen="(".a:prefix." ".a:effect." ".value." <esc>F(l".postCommand
  exec "nmap <space>".a:binding." a".effectString
  exec "nmap <space><space>".a:binding." a".effectStringParen
endfunction


function BindTidalObject(object, binding, ...)
  let l:value= a:0>=1 ? a:1 : "(8/8)"
  let l:effectString=" ".a:object." ".value." <esc>2F(lr"
  exec "nmap <space>o".a:binding." a".effectString
  exec "nmap <space>or".a:binding." a range (1/8) (1) $".effectString
  exec "nmap <space><space>o".a:binding." a (".effectString
  exec "nmap <space><space>or".a:binding." a ( range (1/8) (1) $".effectString
endfunction


"""" audio effects

"" basic stuff
call BindTidalEffect("speed","S","&")
call BindTidalEffect("gain","G","&")
call BindTidalEffect("pan","P","#")
call BindTidalEffect("accelerate","A","#")

"" envelope related
call BindTidalEffect("att","ea","#")
call BindTidalEffect("hold","eh","#")
call BindTidalEffect("rel","er","#")
""" considering this chief to the contour of the sound
call BindTidalEffect("sus","es","#")

"" filters
call BindTidalEffect("lpf","fl","#","(2000*(8/8))")
call BindTidalEffect("lresonance","flr","#")
call BindTidalEffect("lpq","flq","#")

call BindTidalEffect("hpf","fh","#","(2000*(8/8))")
call BindTidalEffect("hresonance","fhr","#")
call BindTidalEffect("hpq","fhq","#")

call BindTidalEffect("bpf","fb","#","(2000*(8/8))")
call BindTidalEffect("bpfq","fbq","#")

call BindTidalEffect("djf","fd","#","(2000*(8/8))")

call BindTidalEffect("vowel","fv","#",'("")',"aa<esc>r")

"" delay/verb
call BindTidalEffect("delay","rd","#")
call BindTidalEffect("delayt","rdt","#")
call BindTidalEffect("delayfb","rdf","#")

call BindTidalEffect("room","r","#")
call BindTidalEffect("size","rs","#")
call BindTidalEffect("size","rd","#")

"" distortions
call BindTidalEffect("shape","ds","#")
call BindTidalEffect("distort","dd","#")
call BindTidalEffect("crush","dc","#")
call BindTidalEffect("coarse","do","#")
call BindTidalEffect("krush","dk","#")
call BindTidalEffect("triode","dt","#")
call BindTidalEffect("waveloss","dw","#")

call BindTidalEffect("binshift","db","#")
call BindTidalEffect("binshift","db","#")

"" modulators
call BindTidalEffect("leslie","le","#")
call BindTidalEffect("lrate","lr","#")
call BindTidalEffect("lsize","ls","#")

call BindTidalEffect("tremolo","lt","#")


""" objects
call BindTidalObject("sine","s","","")
call BindTidalObject("square","q","","")
call BindTidalObject("cosine","c","","")
call BindTidalObject("tri","t","","")
call BindTidalObject("saw","w","","")
call BindTidalObject("rand","a","","")
call BindTidalObject("irand 8","i","","")
call BindTidalObject("envL","e","","")


"""" Pattern functions

"" fast/slow                    \/      \/ ez way to reorder funcs
call BindTidalEffect("fast","f","","(1) $")
call BindTidalEffect("slow","s","","(1) $")

call BindTidalEffect("discretize","D","","(8) $")
call BindTidalEffect("trigger","T","","(1) $")

call BindTidalEffect("linger","l","","(8/8) $")
call BindTidalEffect("ply","p","","(1) $")
call BindTidalEffect("chop","c","","(1) $")
call BindTidalEffect("iter","i","","(1) $")
call BindTidalEffect("degradeBy","d","","(4/8) $")
call BindTidalEffect("shiftBy","b","","(1/8) $")

""" SLICE
execute 'nmap <space>a aslice (8) "0 1 2 3 4 5 6 7" $ '

function InsRangeFunc(i)
	let rnge = system("echo -n \\[{0..".a:i."}\\]")
    call setreg('r',rnge)
endfunction

function InsRangeStrFunc(i)
	let rnge = system("echo -n \\[{0..".a:i."}\\]")
    call setreg('r','"'.rnge.'"')
endfunction

""" custom range (best used with slice I suppose
command -nargs=1 InsRange call InsRangeFunc(<args>) | :normal! "rp
command -nargs=1 InsRangeStr call InsRangeStrFunc(<args>) | :normal! "rp

nmap <space>R :InsRange
nmap <space><space>R :InsRangeStr





"""""""" Manuvering

let searchstring="[\\$\\|\\#\\|&\\|\\\|+]"

execute "map <silent> H ?".searchstring."<CR>"
execute "map <silent> L /".searchstring."<CR>"

let tidal_no_mappings = 1

map <c-u> u 
imap <c-r> <esc><c-r>i

xmap <c-l> <Plug>TidalParagraphSend
nmap <c-l> <Plug>TidalParagraphSend
imap <c-l> <esc><Plug>TidalParagraphSendi

xmap <c-m-l> <CMD>TidalHush<CR><Plug>TidalParagraphSend
nmap <c-m-l> <CMD>TidalHush<CR><Plug>TidalParagraphSend
imap <c-m-l> <esc>:TidalHush<CR><Plug>TidalParagraphSendi

xmap <c-k> <Plug>TidalLineSend
nmap <c-k> <Plug>TidalLineSend
imap <c-k> <esc><Plug>TidalLineSendi


xmap <c-m-k> <CMD>TidalHush<CR><Plug>TidalLineSend
nmap <c-m-k> <CMD>TidalHush<CR><Plug>TidalLineSend
imap <c-m-k> <esc>:TidalHush<CR><Plug>TidalLineSend


"for when you want to send text that isn't just a line or a paragraph
xmap <c-j> <Plug>TidalMotionSend
nmap <c-j> <Plug>TidalMotionSend
imap <c-j> <esc><Plug>TidalMotionSend i

xmap <m-h> :TidalHush <Return>
nmap <m-h> :TidalHush <Return>
imap <m-h> <esc>:TidalHush <Return>i

let g:tidal_preserve_curpos = 1



function! s:TidalJumpPlay(stream)
  silent execute "normal! `".a:stream
  let l:cursor_pos = getpos(".")
  silent execute "normal! vip:TidalSend\<cr>"
  call setpos('.', cursor_pos)
endfunction

command! -nargs=1 TidalJumpPlay call s:TidalJumpPlay(<args>)

function! s:TidalPlayNoVis_(stream)
  let res = search('d' . a:stream)
  let l:cursor_pos = getpos(".")
  if res > 0
    silent execute "normal! vip:TidalSend\<cr>"
  else
    echo "d" . a:stream . " was not found"
  endif
  call setpos('.', cursor_pos)
endfunction

command! -nargs=1 TidalPlayNoVis call s:TidalPlayNoVis_(<args>)

function! s:TidalPlayBackwardsNoVis_(stream)
  let res = search('d' . a:stream,"b")
  let l:cursor_pos = getpos(".")
  if res > 0
    silent execute "normal! vip:TidalSend\<cr>"
  else
    echo "d" . a:stream . " was not found"
  endif
  call setpos('.', cursor_pos)
endfunction

command! -nargs=1 TidalPlayBackwardsNoVis call s:TidalPlayBackwardsNoVis_(<args>)






"" for alt+ any number key, (ie. alt+1, alt+2, etc...)
"" it will evaluate the first d1, d2, etc... it can find that is below your cursor
let i = 1
while i <= 9
  execute 'nnoremap <m-'.i.'> :TidalPlayNoVis'.i.'<cr>'
  execute 'nmap <space>'.i.' :TidalJumpPlay'.i.'<cr>'
  let i += 1
endwhile

execute 'nnoremap <m-!> :TidalPlayBackwardsNoVis1 <cr>'
execute 'nnoremap <m-@> :TidalPlayBackwardsNoVis2 <cr>'
execute 'nnoremap <m-#> :TidalPlayBackwardsNoVis3 <cr>'
execute 'nnoremap <m-$> :TidalPlayBackwardsNoVis4 <cr>'
execute 'nnoremap <m-%> :TidalPlayBackwardsNoVis5 <cr>'
execute 'nnoremap <m-^> :TidalPlayBackwardsNoVis6 <cr>'
execute 'nnoremap <m-&> :TidalPlayBackwardsNoVis7 <cr>'
execute 'nnoremap <m-*> :TidalPlayBackwardsNoVis8 <cr>'
execute 'nnoremap <m-(> :TidalPlayBackwardsNoVis9 <cr>'


"" binding for jumping by "do" instead of "d1, d2, ..."
execute 'nmap <m-d> :TidalPlayNoVis("o")<cr>'
execute 'nmap <m-D> :TidalPlayBackwardsNoVis("o")<cr>'

"" resets the cycle counter
execute 'nnoremap <m-r> :TidalSend1 resetCycles <cr>'

"" resets any effects applied globally
execute 'nnoremap <m-)> :TidalSend1 all $ id <cr>'

execute 'nnoremap <C-s> :TidalSend1 p "midictl" $ midicmd "stop" # s "midi" <cr>'
execute 'nnoremap <C-m-S> :TidalSend1 p "midictl" $ midicmd "start" # s "midi" <cr>'

"" leading to..

"""" applying effects globally
"""" applying effects globally
"""" applying effects globally
"""" applying effects globally




"" when called, 
"" you can either stack an effect on top of others
"" or clear the stack and add your effect


let g:effects_chain = ""

function! s:TidalEffect_(effect, ...)
  if a:0 >= 1
    let g:effects_chain = " __" . a:effect . " . "
  else
    let g:effects_chain = g:effects_chain .  " __" . a:effect . " . "
  endif
  echo g:effects_chain
  execute ':TidalSend1 all $ ' . g:effects_chain . 'id'
endfunction

function! s:RestoreTidalEffects_()
  execute ':TidalSend1 all $ ' . g:effects_chain . 'id'
endfunction

command! RestoreTidalEffects call s:RestoreTidalEffects_()


command! -nargs=1 TidalEffect call s:TidalEffect_(<args>)
command! -nargs=1 TidalEffectClear call s:TidalEffect_(<args>,1)

execute 'nmap <space>E<v:operator> :TidalEffect("l") <CR>'
execute 'nmap <space><space>El :TidalEffectClear("l") <CR>'

"" re-execute effects_chain without adding any new effects
execute 'nmap <space>EE :RestoreTidalEffects<cr>'

"" reset effects
execute 'nmap <space>E<space> :let g:effects_chain = "" <CR>'